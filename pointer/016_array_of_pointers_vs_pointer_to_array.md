# 二维数组 vs 指针数组（Pointer-to-Array vs Array-of-Pointers）

## 学习目标

- 理解二维数组 `int arr[3][4]` 的内存布局
- 区分“指向数组的指针”和“指针数组”
- 学会将二维数组作为函数参数传递
- 学会使用指针访问二维数据结构

## 1. 二维数组 `int arr[3][4]`

```c
int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};
```

这块内存是**连续的**，等价于 12 个 `int` 连续排列。

访问方式：

- `arr[i][j]`
- `*(*(arr + i) + j)`

## 2. 指针数组 `int *arr[3]`

```c
int a[] = {1, 2, 3};
int b[] = {4, 5, 6};
int c[] = {7, 8, 9};

int *arr[3] = {a, b, c};
```

这表示：`arr` 是一个数组，包含 3 个指针，每个指针指向一个一维数组。

访问方式：

`arr[i][j]` 依然可用（因为 `arr[i]` 是 `int *`）

这种结构**不是连续的二维内存**，更灵活，适合**行长度不等**的场景（如生物序列）。

## 对比总结

| 特征         | 二维数组 (`int arr[3][4]`) | 指针数组 (`int *arr[3]`)    |
| ------------ | -------------------------- | --------------------------- |
| 内存布局     | 一整块连续内存             | 每一行单独存储（不连续）    |
| 大小固定     | 是                         | 否（每行可以不同长度）      |
| 函数传参方式 | `int arr[][COL]`           | `int *arr[]` or `int **arr` |
| 访问语法     | `arr[i][j]`                | `arr[i][j]`                 |

## 3. 函数传递二维数组

二维数组:

```c
void print_fixed(int arr[][4], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%d ", arr[i][j]);
        }
    }
}
```

指针数组:

```c
void print_pointer(int *arr[], int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%d ", arr[i][j]);
        }
    }
}
```

## 4. 练习 (来自 ChatGPT)

你有以下序列：

```c
char *seqs[3] = {
    "ATCG",
    "GGTA",
    "CCTA"
};
```

写一个函数 `print_seqs(char *seqs[], int n)`，用指针方式输出所有序列内容。

### 拓展建议（选做）

- 用二维数组 `char seqs[3][10]` 存储 DNA 序列，并尝试交换其中两行
- 使用指针打印任意维数组（例如 `int ***data`）

## QA

### 为什么 `int *arr[3]` 中的指针是 `int *`，却能指向 `int` 类型的数组？

`int *arr[3]` 意思是：**`arr` 是一个数组，数组中每个元素都是 `int *` 类型的指针**，即：它们指向的是某个 `int`。

> 注意：不是指向“数组”，而是“数组的首元素”

#### 本质：

你可以把数组看作是**一段连续的 `int` 值的集合**，而数组名（或数组的地址）其实就是指向第一个元素的指针。

```c
int a[] = {1, 2, 3};
int *p = a;       // 合法，a 是 int*，指向 a[0]
```

所以 `arr[0] = a;` 是将 a（数组首地址）赋值给 `int *arr[0]`，是完全匹配的。

---

### 为什么 `arr[i][j]` 在指针数组中依然可用？

```c
int *arr[3]; // arr 是数组，每个元素是 int *
```

这时：

- `arr[i]` 是一个 `int *`，也就是一个**指向一维数组的首地址**
- 所以 `arr[i][j]` 等价于 `*(*(arr + i) + j)`

```c
int a[] = {1, 2, 3};
int b[] = {4, 5, 6};
int *arr[2] = {a, b};

// arr[0] → a → {1, 2, 3}
// arr[1] → b → {4, 5, 6}

arr[1][2]  ===  *( *(arr + 1) + 2 ) === b[2] === 6
```

所以 `arr[i][j]` 在语法上仍然合法：第一层是“数组中第 i 个指针”，第二层是“指针指向数组中的第 j 个元素”。

---

### 二维数组作为函数参数会退化为指针吗？

#### 结论：部分退化，但有区别！

当你写：

```c
void func(int arr[3][4]);     // 固定大小二维数组参数
void func(int arr[][4]);      // 等价写法
```

实际上，**参数 `arr` 退化成了指向一维数组的指针**：

```c
int (*arr)[4];  // arr 是一个指针，指向含有 4 个 int 的数组
```

#### 注意：不能完全退化成 int \*\*

如果你写：

```c
void func(int **arr);
```

你不能直接把二维数组 `int arr[3][4]` 传给它，因为：

- `int arr[3][4]` 是一整块连续内存
- `int **` 是指针的指针（例如：数组中的每一行是 `int *`）
- 两者内存布局不同

---

### `int *arr[3]`; 是否可以写成 `int* arr[3];`？

可以写成 `int* arr[3];`，**语法是合法的，含义不变**，它仍然是 “一个长度为 3 的数组，数组中每个元素是 `int*`(int 指针)”

但是推荐写成 `int *arr[3];`。因为在 C 中，`*` 是变量声明的一部分，而不是类型的一部分。

```c
int* a, b;    // ❌ b 是 int，不是 int*
int *a, b;    // 更清楚：a 是 int*，b 是 int
int *a, *b;   // 更一致，更少歧义
```

---

### 为什么二维数组不会退化成 `int **`，而是 `int (*)[n]`？

#### 根本原因：二维数组在内存中是连续的，而 int \*\* 是不连续的结构

#### 情况 A：二维数组（如 `int arr[3][4]`）

他的内存结构是连续的:

- 它是一整块内存（共 3×4 = 12 个 `int`）
- 传参时，数组退化为：**指向每一行的指针**
  - 每一行是 `int[4]`
  - 函数接受 `int (*arr)[4]`，也就是“指向 4 个 int 的数组的指针”

#### 情况 B：`int **`（指针的指针）

内存结构不连续:

- `arr` 是一个指针，指向多个 `int *`（行首指针）
- 每一行可以来自不同 malloc，**不要求连续**

#### 为什么 int arr[3][4] 不能传给 int \*\*？

因为：

- `int arr[3][4]` 是连续的内存
- `int **` 是一个“指针的数组结构”，期望每一行是一个 `int *`
- 它们在内存结构上完全不兼容！

### 总结

| 原始类型        | 实际传参退化后 | 说明                               |
| --------------- | -------------- | ---------------------------------- |
| `int arr[3]`    | `int *`        | 一维数组退化为指向 int 的指针      |
| `int arr[3][4]` | `int (*)[4]`   | 二维数组退化为“指向一维数组”的指针 |
| `int *arr[3]`   | `int **`       | 指针数组退化为指向指针的指针       |
